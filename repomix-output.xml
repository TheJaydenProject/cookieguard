This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
LICENSE
PRIVACY.md
README.md
src/assets/icons/icon128.png
src/assets/icons/icon16.png
src/assets/icons/icon48.png
src/background/classifier.js
src/background/service-worker.js
src/background/storage.js
src/lib/psl.js
src/lib/utils.js
src/manifest.json
src/popup/popup.html
src/popup/popup.js
src/popup/style.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="LICENSE">
MIT License

Copyright (c) 2026 TheJaydenProject

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="PRIVACY.md">
# Privacy Policy for CookieGuard

**Effective Date:** January 7, 2026

CookieGuard is an open-source browser extension designed to provide visibility into cookie activity. We believe in complete user sovereignty and data privacy.

## Data Collection
**CookieGuard does not collect, transmit, or share any user data.** * **No Remote Telemetry:** The extension has no analytics, tracking, or "ping home" functionality.
* **No External Servers:** All processing, risk classification, and analysis happen locally on your device (Client-Side).
* **No Third-Party Sharing:** Since we do not collect data, we have no data to share with third parties.

## Local Data Storage
The extension stores data locally in your browser's `storage.local` and `storage.session` APIs solely for the purpose of functionality:
* **Cookie History:** Logs of cookie events are stored to populate the "History" tab. This data never leaves your browser.
* **Settings:** User preferences (e.g., theme, muted domains) are stored locally.

## User Rights
You have full control over your data:
* **View Data:** You can view all stored data in the extension's dashboard.
* **Clear Data:** You can clear your history and settings at any time using the "Clear History" button.
* **Export Data:** You can export your local data for your own records.

## Contact
For questions or to audit the code, please visit our GitHub repository.
</file>

<file path="README.md">
# CookieGuard
</file>

<file path="src/background/classifier.js">
import { sanitizeInput } from '../lib/utils.js';

const TRACKING_KEYWORDS = [
  '_ga', '_gid', '_fbp', '_fbc', 'utm_', '__utma', '__utmz',
  'doubleclick', 'adsense', 'adroll', 'criteo', '_hjid',
  'optimizely', 'mixpanel', 'segment', 'amplitude',
  'pixel', 'tracker', 'uuid'
];

const ANALYTICS_KEYWORDS = [
  'analytics', 'stats', 'metrics', '_gat', 'matomo', 'piwik',
  'hotjar', 'newrelic', 'datadog', 'sentry',
];

const FUNCTIONAL_KEYWORDS = [
  'session', 'auth', 'token', 'csrf', 'xsrf', 'login',
  'user', 'pref', 'lang', 'locale', 'timezone', 'theme',
  'cart', 'checkout', 'order', 'payment',
];

export function classifyCookie(cookie, isThirdParty) {
  const safeName = sanitizeInput(cookie.name).toLowerCase();
  const safeValue = sanitizeInput(cookie.value || "").toLowerCase();
  
  const isPartitioned = !!cookie.partitionKey;

  if (isThirdParty) {
    if (!isPartitioned) {
      return 'high';
    } else {
      return 'medium';
    }
  }

  const matches = (keywords) => keywords.some(k => safeName.includes(k) || safeValue.includes(k));

  if (matches(TRACKING_KEYWORDS)) {
    return 'medium';
  }

  if (matches(ANALYTICS_KEYWORDS)) {
    return 'medium';
  }

  if (matches(FUNCTIONAL_KEYWORDS)) {
    return 'low';
  }

  if (!cookie.expirationDate) {
    return 'low'; 
  }

  return 'low';
}
</file>

<file path="src/background/service-worker.js">
import { classifyCookie } from './classifier.js';
import { StorageManager } from './storage.js';
import { createIdentityHash, sanitizeInput, isIncognito } from '../lib/utils.js';
import { getETLDPlus1, isThirdParty } from '../lib/psl.js';

let storageQueue = [];
const STORAGE_ALARM_NAME = 'batch_storage_write';
const storage = new StorageManager();

const state = {
  identityMap: new Map(),
  circuitBreakers: new Map(),
  tabDomainCache: new Map(),
  isRestored: false
};

const CIRCUIT_BREAKER_THRESHOLD = 50;
const CIRCUIT_BREAKER_COOLDOWN = 10000;
const NOTIFICATION_BUFFER_DELAY = 800;
const SESSION_BACKUP_KEY = 'cg_session_state';
const SAVE_ALARM_NAME = 'save_state_debounce';

let notificationTimers = new Map();

browser.runtime.onInstalled.addListener(async (details) => {
  if (details.reason === 'install') {
    await browser.tabs.create({ url: browser.runtime.getURL('popup/popup.html?firstLaunch=true') });
  }
  await init();
});

browser.runtime.onStartup.addListener(init);

browser.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name === SAVE_ALARM_NAME) {
    try {
      const serialized = Array.from(state.identityMap.entries());
      await browser.storage.session.set({ [SESSION_BACKUP_KEY]: serialized });
    } catch (e) {
      console.error('[CookieGuard] State save failed:', e);
    }
  }
  else if (alarm.name === STORAGE_ALARM_NAME) {
    await flushStorageQueue();
  }
});

async function flushStorageQueue() {
  if (storageQueue.length === 0) return;
  
  const batch = [...storageQueue];
  storageQueue = [];
  
  try {
    await storage.appendEvents(batch);
  } catch (e) {
    console.error('[CookieGuard] Storage flush failed:', e);
  }
}

async function init() {
  await storage.init();
  await restoreSessionState();
  
  if (state.identityMap.size === 0) {
    await hydrateCookies();
  }
  
  state.isRestored = true;
  console.log('[CookieGuard] System Initialized. Tracking:', state.identityMap.size, 'cookies');
}

browser.cookies.onChanged.addListener(async (changeInfo) => {
  if (!state.isRestored) await restoreSessionState();

  const { cookie, removed, cause } = changeInfo;
  
  const isPrivate = isIncognito(cookie.storeId);
  if (isPrivate) {
    const settings = await storage.getSettings();
    if (!settings.incognitoEnabled) return;
  }

  const etld = getETLDPlus1(cookie.domain);
  if (checkCircuitBreaker(etld)) return;

  const mutedDomains = await storage.getMutedDomains();
  if (mutedDomains[etld]) return;

  const identityHash = await createIdentityHash(cookie);
  const existing = state.identityMap.get(identityHash);

  if (existing && !removed) {
    existing.lastSeen = Date.now();
    existing.changeCount++;
    triggerStateSave();
    return;
  }

  let classification = 'low';
  let is3rdParty = false;

  if (!removed) {
    is3rdParty = isThirdParty(cookie.domain, null);
    classification = classifyCookie({
      ...cookie,
      value: cookie.value ? cookie.value.substring(0, 100) : ""
    }, is3rdParty);
  }

  const eventRecord = {
    identityHash,
    timestamp: Date.now(),
    action: removed ? 'removed' : 'added',
    cause: cause || 'unknown',
    name: sanitizeInput(cookie.name),
    domain: sanitizeInput(cookie.domain),
    path: sanitizeInput(cookie.path),
    etld,
    storeId: cookie.storeId,
    riskLevel: classification,
    isThirdParty: is3rdParty,
    isPartitioned: !!cookie.partitionKey,
    secure: cookie.secure,
    httpOnly: cookie.httpOnly,
    sameSite: cookie.sameSite,
    session: cookie.session,
    changeCount: 1,
    lastSeen: Date.now()
  };

  if (removed) {
    state.identityMap.delete(identityHash);
  } else {
    state.identityMap.set(identityHash, eventRecord);
  }

  triggerStateSave();

  if (!removed && classification === 'high' && !isPrivate) {
    scheduleNotification(etld);
  }

  if (cookie.storeId === '0') {
    storageQueue.push(eventRecord);

    const alarm = await browser.alarms.get(STORAGE_ALARM_NAME);
    if (!alarm) {
      browser.alarms.create(STORAGE_ALARM_NAME, { delayInMinutes: 0.05 });
    }
  }
});

async function restoreSessionState() {
  try {
    const data = await browser.storage.session.get(SESSION_BACKUP_KEY);
    if (data[SESSION_BACKUP_KEY]) {
      state.identityMap = new Map(data[SESSION_BACKUP_KEY]);
    }
  } catch (e) {
    console.warn('[CookieGuard] State restore failed:', e);
  }
}

function triggerStateSave() {
  browser.alarms.create(SAVE_ALARM_NAME, { delayInMinutes: 0.05 });
}

async function hydrateCookies() {
  try {
    const allCookies = await browser.cookies.getAll({});
    for (const cookie of allCookies) {
      const etld = getETLDPlus1(cookie.domain);
      const is3rdParty = isThirdParty(cookie.domain, null);
      
      const classification = classifyCookie({
        ...cookie,
        value: ""
      }, is3rdParty);

      const identityHash = await createIdentityHash(cookie);
      
      state.identityMap.set(identityHash, {
        identityHash,
        timestamp: Date.now(),
        action: 'hydrated',
        name: sanitizeInput(cookie.name),
        domain: sanitizeInput(cookie.domain),
        path: sanitizeInput(cookie.path),
        etld,
        storeId: cookie.storeId,
        riskLevel: classification,
        isThirdParty,
        isPartitioned: !!cookie.partitionKey,
        secure: cookie.secure,
        httpOnly: cookie.httpOnly,
        sameSite: cookie.sameSite,
        session: cookie.session,
        changeCount: 1,
        lastSeen: Date.now()
      });
    }
    triggerStateSave();
  } catch (e) {
    console.error('[CookieGuard] Hydration failed:', e);
  }
}

function checkCircuitBreaker(domain) {
  const now = Date.now();
  const breaker = state.circuitBreakers.get(domain) || { count: 0, resetTime: now + 1000 };

  if (now > breaker.resetTime) {
    breaker.count = 1;
    breaker.resetTime = now + 1000;
  } else {
    breaker.count++;
  }

  state.circuitBreakers.set(domain, breaker);

  if (breaker.count > CIRCUIT_BREAKER_THRESHOLD) {
    if (!breaker.tripTime) {
      breaker.tripTime = now;
      console.warn(`[CookieGuard] Circuit breaker tripped: ${domain}`);
    }
    return (now - breaker.tripTime) < CIRCUIT_BREAKER_COOLDOWN;
  }
  return false;
}

function scheduleNotification(domain) {
  if (notificationTimers.has(domain)) return;
  
  const id = setTimeout(() => {
    browser.notifications.create({
      type: 'basic',
      iconUrl: '../assets/icons/icon48.png',
      title: 'CookieGuard Alert',
      message: `High-risk tracking detected: ${domain}`
    });
    notificationTimers.delete(domain);
  }, NOTIFICATION_BUFFER_DELAY);
  
  notificationTimers.set(domain, id);
}

browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
  (async () => {
    try {
      if (message.type === 'GET_COOKIES') {
        if (!state.isRestored) await restoreSessionState();
        sendResponse({
          cookies: Array.from(state.identityMap.values()),
          circuitBreakers: Array.from(state.circuitBreakers.entries())
            .filter(([_, b]) => b.tripTime && (Date.now() - b.tripTime < CIRCUIT_BREAKER_COOLDOWN))
            .map(([d]) => d)
        });
      }
      else if (message.type === 'GET_HISTORY') {
        const history = await storage.getHistory(message.limit || 100);
        sendResponse({ history });
      }
      else if (message.type === 'MUTE_DOMAIN') {
        await storage.muteDomain(message.domain, true);
        sendResponse({ success: true });
      }
      else if (message.type === 'UNMUTE_DOMAIN') {
        await storage.unmuteDomain(message.domain);
        sendResponse({ success: true });
      }
      else if (message.type === 'GET_SETTINGS') {
        const settings = await storage.getSettings();
        sendResponse({ settings });
      }
      else if (message.type === 'UPDATE_SETTINGS') {
        await storage.updateSettings(message.settings);
        sendResponse({ success: true });
      }
      else if (message.type === 'CLEAR_HISTORY') {
        await storage.clearHistory();
        sendResponse({ success: true });
      }
      else if (message.type === 'EXPORT_DATA') {
        const data = await storage.exportData(message.includeValues);
        sendResponse({ data });
      }
    } catch (e) {
      sendResponse({ error: e.message });
    }
  })();
  return true;
});
</file>

<file path="src/background/storage.js">
const MAX_RETAINED_EVENTS = 5000;
const PRUNE_THRESHOLD = 5500;
const STORAGE_KEYS = {
  SETTINGS: 'cg_settings',
  MUTED_DOMAINS: 'cg_muted_domains',
  HISTORY: 'cg_history',
  METADATA: 'cg_metadata',
};

const DEFAULT_SETTINGS = {
  incognitoEnabled: false,
  developerMode: false,
  notificationsEnabled: true,
  autoMuteBigTech: false,
  theme: 'auto',
};

export class StorageManager {
  constructor() {
    this.initialized = false;
  }
  
  async init() {
    if (this.initialized) return;
    
    try {
      const stored = await browser.storage.local.get(STORAGE_KEYS.SETTINGS);
      if (!stored[STORAGE_KEYS.SETTINGS]) {
        await browser.storage.local.set({
          [STORAGE_KEYS.SETTINGS]: DEFAULT_SETTINGS,
        });
      }
      
      const muted = await browser.storage.local.get(STORAGE_KEYS.MUTED_DOMAINS);
      if (!muted[STORAGE_KEYS.MUTED_DOMAINS]) {
        await browser.storage.local.set({
          [STORAGE_KEYS.MUTED_DOMAINS]: {},
        });
      }
      
      const history = await browser.storage.local.get(STORAGE_KEYS.HISTORY);
      if (!history[STORAGE_KEYS.HISTORY]) {
        await browser.storage.local.set({
          [STORAGE_KEYS.HISTORY]: [],
        });
      }
      
      await browser.storage.local.set({
        [STORAGE_KEYS.METADATA]: {
          version: '3.2',
          lastPrune: Date.now(),
          totalEvents: 0,
        },
      });
      
      this.initialized = true;
    } catch (error) {
      console.error('[StorageManager] Init failed:', error);
      throw error;
    }
  }
  
  async appendEvents(events) {
    if (events.length === 0) return;
    
    try {
      const persistentEvents = events.filter(e => !e.isIncognito);
      
      if (persistentEvents.length === 0) {
        return;
      }
      
      const stored = await browser.storage.local.get(STORAGE_KEYS.HISTORY);
      const history = stored[STORAGE_KEYS.HISTORY] || [];
      
      const updated = [...history, ...persistentEvents];
      
      let final = updated;
      if (updated.length > PRUNE_THRESHOLD) {
        final = this.pruneHistory(updated);
      }
      
      await browser.storage.local.set({
        [STORAGE_KEYS.HISTORY]: final,
      });
      
      const meta = await this.getMetadata();
      meta.totalEvents += persistentEvents.length;
      meta.lastWrite = Date.now();
      await browser.storage.local.set({
        [STORAGE_KEYS.METADATA]: meta,
      });
      
    } catch (error) {
      console.error('[StorageManager] Append failed:', error);
      throw error;
    }
  }
  
  pruneHistory(events) {
    const sorted = [...events].sort((a, b) => b.timestamp - a.timestamp);
    const pruned = sorted.slice(0, MAX_RETAINED_EVENTS);
    
    browser.storage.local.get(STORAGE_KEYS.METADATA).then(stored => {
      const meta = stored[STORAGE_KEYS.METADATA] || {};
      meta.lastPrune = Date.now();
      meta.prunedCount = (meta.prunedCount || 0) + (events.length - pruned.length);
      browser.storage.local.set({ [STORAGE_KEYS.METADATA]: meta });
    });
    
    return pruned;
  }
  
  async getHistory(limit = 100) {
    try {
      const stored = await browser.storage.local.get(STORAGE_KEYS.HISTORY);
      const history = stored[STORAGE_KEYS.HISTORY] || [];
      
      return history
        .sort((a, b) => b.timestamp - a.timestamp)
        .slice(0, limit);
    } catch (error) {
      return [];
    }
  }
  
  async clearHistory() {
    try {
      await browser.storage.local.set({
        [STORAGE_KEYS.HISTORY]: [],
      });
      
      const meta = await this.getMetadata();
      meta.totalEvents = 0;
      meta.lastClear = Date.now();
      await browser.storage.local.set({
        [STORAGE_KEYS.METADATA]: meta,
      });
    } catch (error) {
      throw error;
    }
  }
  
  async getMutedDomains() {
    try {
      const stored = await browser.storage.local.get(STORAGE_KEYS.MUTED_DOMAINS);
      return stored[STORAGE_KEYS.MUTED_DOMAINS] || {};
    } catch (error) {
      return {};
    }
  }
  
  async muteDomain(domain, manual = false) {
    try {
      const muted = await this.getMutedDomains();
      muted[domain] = {
        timestamp: Date.now(),
        manual,
      };
      
      await browser.storage.local.set({
        [STORAGE_KEYS.MUTED_DOMAINS]: muted,
      });
    } catch (error) {
      throw error;
    }
  }
  
  async unmuteDomain(domain) {
    try {
      const muted = await this.getMutedDomains();
      delete muted[domain];
      
      await browser.storage.local.set({
        [STORAGE_KEYS.MUTED_DOMAINS]: muted,
      });
    } catch (error) {
      throw error;
    }
  }
  
  async getSettings() {
    try {
      const stored = await browser.storage.local.get(STORAGE_KEYS.SETTINGS);
      return { ...DEFAULT_SETTINGS, ...stored[STORAGE_KEYS.SETTINGS] };
    } catch (error) {
      return DEFAULT_SETTINGS;
    }
  }
  
  async updateSettings(updates) {
    try {
      const current = await this.getSettings();
      const merged = { ...current, ...updates };
      
      await browser.storage.local.set({
        [STORAGE_KEYS.SETTINGS]: merged,
      });
    } catch (error) {
      throw error;
    }
  }
  
  async getMetadata() {
    try {
      const stored = await browser.storage.local.get(STORAGE_KEYS.METADATA);
      return stored[STORAGE_KEYS.METADATA] || {
        version: '3.2',
        totalEvents: 0,
        lastPrune: null,
        prunedCount: 0,
      };
    } catch (error) {
      return {};
    }
  }
  
  async exportData(includeValues = false) {
    try {
      const settings = await this.getSettings();
      
      if (!settings.developerMode) {
        throw new Error('Developer mode required for export');
      }
      
      const history = await browser.storage.local.get(STORAGE_KEYS.HISTORY);
      const muted = await this.getMutedDomains();
      const metadata = await this.getMetadata();
      
      const exportData = {
        version: '3.2',
        exportDate: new Date().toISOString(),
        metadata,
        settings: {
          ...settings,
          developerMode: undefined,
        },
        mutedDomains: muted,
        history: includeValues 
          ? history[STORAGE_KEYS.HISTORY]
          : history[STORAGE_KEYS.HISTORY].map(e => ({
              ...e,
              value: '[REDACTED]',
            })),
        disclaimer: includeValues
          ? 'WARNING: This export includes cookie values. Handle with care.'
          : 'Cookie values have been redacted for privacy.',
      };
      
      return exportData;
    } catch (error) {
      throw error;
    }
  }
  
  async getStorageStats() {
    try {
      const bytesInUse = await browser.storage.local.getBytesInUse();
      const history = await this.getHistory(1);
      const metadata = await this.getMetadata();
      
      return {
        bytesInUse,
        bytesAvailable: browser.storage.local.QUOTA_BYTES - bytesInUse,
        percentUsed: ((bytesInUse / browser.storage.local.QUOTA_BYTES) * 100).toFixed(2),
        eventCount: metadata.totalEvents,
        retainedEvents: history.length,
        lastPrune: metadata.lastPrune ? new Date(metadata.lastPrune).toISOString() : 'never',
      };
    } catch (error) {
      return null;
    }
  }
}
</file>

<file path="src/lib/psl.js">
const COMMON_SUFFIXES = new Set([
  'com', 'org', 'net', 'edu', 'gov', 'mil', 'int',
  'io', 'co', 'ai', 'app', 'dev',
  'co.uk', 'ac.uk', 'gov.uk', 'org.uk',
  'co.jp', 'ne.jp', 'ac.jp', 'go.jp',
  'com.au', 'net.au', 'org.au', 'edu.au',
  'com.sg', 'edu.sg', 'org.sg', 'net.sg',
  'co.kr', 'ne.kr', 'or.kr',
  'com.br', 'gov.br',
  'co.in', 'net.in',
  'co.nz', 'org.nz',
  'github.io', 'gitlab.io', 'herokuapp.com',
  'azurewebsites.net', 'vercel.app', 'netlify.app'
]);

export function getETLDPlus1(hostname) {
  if (!hostname) return "unknown";
  
  const host = hostname.endsWith('.') ? hostname.slice(0, -1) : hostname;
  const parts = host.toLowerCase().split('.');

  if (parts.length <= 1) return host;
  
  const threePart = parts.slice(-3).join('.');
  if (COMMON_SUFFIXES.has(threePart)) {
    return parts.slice(-4).join('.');
  }

  const twoPart = parts.slice(-2).join('.');
  if (COMMON_SUFFIXES.has(twoPart)) {
    return parts.slice(-3).join('.');
  }
  
  return parts.slice(-2).join('.');
}

export function isThirdParty(cookieDomain, tabUrl) {
  try {
    if (!tabUrl || tabUrl.startsWith('chrome:') || tabUrl.startsWith('about:') || tabUrl.startsWith('moz-extension:')) {
      return false;
    }

    const tabHost = new URL(tabUrl).hostname;
    const cleanCookieDomain = cookieDomain.startsWith('.') ? cookieDomain.slice(1) : cookieDomain;

    const tabETLD = getETLDPlus1(tabHost);
    const cookieETLD = getETLDPlus1(cleanCookieDomain);

    return tabETLD !== cookieETLD;
  } catch (e) {
    return true; 
  }
}
</file>

<file path="src/lib/utils.js">
export async function createIdentityHash(cookie) {
  const identity = `${cookie.storeId}|${cookie.domain}|${cookie.path}|${cookie.name}`;
  const encoder = new TextEncoder();
  const data = encoder.encode(identity);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  return hashHex.substring(0, 32);
}

export function sanitizeInput(input, maxLength = 256) {
  if (!input) return '';
  let cleaned = String(input);
  cleaned = cleaned.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
  if (cleaned.length > maxLength) {
    cleaned = cleaned.substring(0, maxLength);
  }
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return cleaned.replace(/[&<>"']/g, m => map[m]);
}

export function isIncognito(storeId) {
  return storeId === '1';
}

export function formatTime(timestamp) {
  if (!timestamp) return '';
  return new Date(timestamp).toLocaleTimeString([], { 
    hour: '2-digit', 
    minute: '2-digit', 
    second: '2-digit' 
  });
}
</file>

<file path="src/popup/popup.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'">
  <title>CookieGuard</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header class="header">
    <div class="header-content">
      <h1 class="logo">
        <svg class="logo-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"></circle>
          <circle cx="12" cy="12" r="3"></circle>
          <line x1="12" y1="2" x2="12" y2="4"></line>
          <line x1="12" y1="20" x2="12" y2="22"></line>
          <line x1="4.93" y1="4.93" x2="6.34" y2="6.34"></line>
          <line x1="17.66" y1="17.66" x2="19.07" y2="19.07"></line>
          <line x1="2" y1="12" x2="4" y2="12"></line>
          <line x1="20" y1="12" x2="22" y2="12"></line>
          <line x1="6.34" y1="17.66" x2="4.93" y2="19.07"></line>
          <line x1="19.07" y1="4.93" x2="17.66" y2="6.34"></line>
        </svg>
        <span class="logo-text">CookieGuard</span>
      </h1>
      <div class="header-actions">
        <button id="settingsBtn" class="icon-btn" title="Settings" aria-label="Settings">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </button>
        <button id="refreshBtn" class="icon-btn" title="Refresh" aria-label="Refresh">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M23 4v6h-6M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"></path>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="stats-bar">
      <div class="stat">
        <span class="stat-label">Active</span>
        <span id="activeCookies" class="stat-value">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">High Risk</span>
        <span id="highRiskCount" class="stat-value stat-risk">0</span>
      </div>
      <div class="stat">
        <span class="stat-label">Muted</span>
        <span id="mutedCount" class="stat-value">0</span>
      </div>
    </div>
  </header>

  <nav class="tabs">
    <button class="tab active" data-tab="active">Active</button>
    <button class="tab" data-tab="history">History</button>
    <button class="tab" data-tab="muted">Muted</button>
  </nav>

  <main class="content">
    <div id="activeTab" class="tab-content active">
      <div class="filter-bar">
        <input type="search" id="searchInput" placeholder="Search cookies..." class="search-input">
        <select id="riskFilter" class="filter-select">
          <option value="all">All Risk Levels</option>
          <option value="high">High Risk Only</option>
          <option value="medium">Medium Risk</option>
          <option value="low">Low Risk</option>
        </select>
      </div>

      <div id="circuitBreakerAlerts" class="alert-container"></div>

      <div id="cookieList" class="cookie-list">
        <div class="empty-state">
          <svg class="empty-icon" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
            <line x1="9" y1="9" x2="9.01" y2="9"></line>
            <line x1="15" y1="9" x2="15.01" y2="9"></line>
          </svg>
          <p class="empty-title">No cookies detected</p>
          <p class="empty-subtitle">Browse websites to see cookie activity</p>
        </div>
      </div>
    </div>

    <div id="historyTab" class="tab-content">
      <div class="history-notice">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path>
        </svg>
        <span>Last 5,000 events retained</span>
      </div>
      
      <div class="history-controls">
        <select id="historyLimit" class="filter-select">
          <option value="50">Last 50 events</option>
          <option value="100" selected>Last 100 events</option>
          <option value="500">Last 500 events</option>
          <option value="1000">Last 1000 events</option>
        </select>
        <button id="clearHistoryBtn" class="btn btn-danger">Clear History</button>
      </div>

      <div id="historyList" class="history-list">
        <div class="empty-state">
          <svg class="empty-icon" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
          </svg>
          <p class="empty-title">No history yet</p>
          <p class="empty-subtitle">Cookie events will appear here</p>
        </div>
      </div>
    </div>

    <div id="mutedTab" class="tab-content">
      <div class="muted-notice">
        <p>Muted domains will not trigger notifications or appear in the active list.</p>
      </div>

      <div id="mutedList" class="muted-list">
        <div class="empty-state">
          <svg class="empty-icon" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
            <line x1="23" y1="9" x2="17" y2="15"></line>
            <line x1="17" y1="9" x2="23" y2="15"></line>
          </svg>
          <p class="empty-title">No muted domains</p>
          <p class="empty-subtitle">Mute domains from cookie context menus</p>
        </div>
      </div>
    </div>
  </main>

  <div id="settingsPanel" class="settings-panel">
    <div class="settings-header">
      <button id="settingsBackBtn" class="nav-back-btn" aria-label="Back">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
      </button>
      <h2>Settings</h2>
      <div style="width: 24px;"></div> </div>
    
    <div class="settings-body">
      <div class="setting-group">
        <h3>Privacy</h3>
        <label class="setting-row">
          <div class="setting-info">
            <span class="setting-label">Incognito Mode Support</span>
            <span class="setting-description">Monitor cookies in private windows</span>
          </div>
          <input type="checkbox" id="incognitoEnabled" class="toggle">
        </label>
      </div>

      <div class="setting-group">
        <h3>Notifications</h3>
        <label class="setting-row">
          <div class="setting-info">
            <span class="setting-label">Enable Notifications</span>
            <span class="setting-description">Show alerts for high-risk cookies</span>
          </div>
          <input type="checkbox" id="notificationsEnabled" class="toggle">
        </label>
      </div>

      <div class="setting-group">
        <h3>Appearance</h3>
        <label class="setting-row">
          <div class="setting-info">
            <span class="setting-label">Theme</span>
          </div>
          <select id="themeSelect" class="setting-select">
            <option value="auto">Auto (System)</option>
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </label>
      </div>

      <div class="setting-group">
        <h3>Developer</h3>
        <label class="setting-row">
          <div class="setting-info">
            <span class="setting-label">Developer Mode</span>
            <span class="setting-description">Enable data export tools</span>
          </div>
          <input type="checkbox" id="developerMode" class="toggle">
        </label>

        <div id="developerOptions" class="developer-options" style="display: none;">
          <button id="exportDataBtn" class="btn btn-secondary">Export Data (Metadata)</button>
          <button id="exportWithValuesBtn" class="btn btn-danger">Export Data (Values)</button>
        </div>
      </div>

      <div class="setting-group">
        <h3>Storage</h3>
        <div class="storage-stats-clean">
          <div class="stat-clean">
             <span class="stat-key">Used</span>
             <span class="stat-val" id="storageUsed">-</span>
          </div>
          <div class="stat-clean">
             <span class="stat-key">Events</span>
             <span class="stat-val" id="eventsRetained">-</span>
          </div>
        </div>
      </div>

      <div class="settings-footer-info">
        <p>CookieGuard v3.2</p>
        <p class="subtle">Local-only architecture. Zero external tracking.</p>
      </div>
    </div>
  </div>

  <div id="detailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Cookie Details</h2>
        <button class="modal-close" aria-label="Close">&times;</button>
      </div>
      
      <div class="modal-body" id="detailContent"></div>

      <div class="modal-footer">
        <button id="muteDomainBtn" class="btn btn-secondary">Mute Domain</button>
        <button class="btn btn-primary modal-close">Close</button>
      </div>
    </div>
  </div>

  <div id="firstLaunchModal" class="modal" style="display: none;">
    <div class="modal-content wizard">
      <div class="modal-body">
        <div class="wizard-container">
          <div class="wizard-header">
            <div class="wizard-icon">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
              </svg>
            </div>
            <h1 class="wizard-title">Privacy-First Cookie Visibility</h1>
            <p class="wizard-subtitle">Monitor real-time cookie activity with complete transparency. All data stays local.</p>
          </div>

          <div class="wizard-features">
            <div class="wizard-feature">
              <div class="wizard-feature-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                </svg>
              </div>
              <div class="wizard-feature-content">
                <h3 class="wizard-feature-title">Real-Time Monitoring</h3>
                <p class="wizard-feature-text">Track cookies as they are created and modified across all your browsing sessions</p>
              </div>
            </div>

            <div class="wizard-feature">
              <div class="wizard-feature-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                  <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
              </div>
              <div class="wizard-feature-content">
                <h3 class="wizard-feature-title">Local-Only Storage</h3>
                <p class="wizard-feature-text">Your data never leaves your device. Complete privacy guaranteed with zero cloud sync</p>
              </div>
            </div>

            <div class="wizard-feature">
              <div class="wizard-feature-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                  <circle cx="12" cy="12" r="3"></circle>
                </svg>
              </div>
              <div class="wizard-feature-content">
                <h3 class="wizard-feature-title">Risk Classification</h3>
                <p class="wizard-feature-text">Automatic assessment of tracking cookies and third-party data collection</p>
              </div>
            </div>
          </div>

          <div class="wizard-philosophy">
            <h4 class="wizard-philosophy-title">Our Philosophy</h4>
            <p class="wizard-philosophy-text">Visibility does not equal protection. We provide the information. You make the informed choice about your privacy.</p>
          </div>

          <button id="completeWizardBtn" class="wizard-cta">Get Started</button>
        </div>
      </div>
    </div>
  </div>

  <script type="module" src="popup.js"></script>
</body>
</html>
</file>

<file path="src/popup/popup.js">
import { sanitizeInput, formatTime } from '../lib/utils.js';

const state = {
  cookies: [],
  history: [],
  mutedDomains: {},
  settings: {},
  filters: { search: '', risk: 'all' },
  currentTab: 'active',
  selectedCookie: null,
};

document.addEventListener('DOMContentLoaded', async () => {
  initializeEventListeners();

  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('firstLaunch') === 'true') {
    showFirstLaunchWizard();
    return;
  }
  
  await loadSettings();
  await loadData();
  setInterval(refreshActiveData, 3000);
});

function initializeEventListeners() {
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', (e) => switchTab(e.target.dataset.tab));
  });
  
  document.getElementById('settingsBtn').addEventListener('click', openSettings);
  document.getElementById('settingsBackBtn').addEventListener('click', closeSettings);
  document.getElementById('refreshBtn').addEventListener('click', refreshActiveData);
  
  document.getElementById('searchInput').addEventListener('input', (e) => {
    state.filters.search = e.target.value.toLowerCase();
    renderCookieList();
  });
  
  document.getElementById('riskFilter').addEventListener('change', (e) => {
    state.filters.risk = e.target.value;
    renderCookieList();
  });
  
  document.getElementById('historyLimit').addEventListener('change', loadHistory);
  document.getElementById('clearHistoryBtn').addEventListener('click', clearHistory);
  
  document.querySelectorAll('.modal-close').forEach(btn => {
    btn.addEventListener('click', closeModals);
  });
  
  ['incognitoEnabled', 'notificationsEnabled', 'developerMode'].forEach(id => {
    document.getElementById(id).addEventListener('change', autoSaveSettings);
  });
  
  document.getElementById('themeSelect').addEventListener('change', autoSaveSettings);
  
  document.getElementById('exportDataBtn').addEventListener('click', () => exportData(false));
  document.getElementById('exportWithValuesBtn').addEventListener('click', () => exportData(true));
  document.getElementById('muteDomainBtn').addEventListener('click', muteDomainFromDetail);
  document.getElementById('completeWizardBtn')?.addEventListener('click', completeWizard);
  
  document.querySelectorAll('.modal').forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) closeModals();
    });
  });
}

async function loadData() {
  await Promise.all([loadActiveCookies(), loadHistory(), loadMutedDomains()]);
}

async function loadActiveCookies() {
  try {
    const response = await browser.runtime.sendMessage({ type: 'GET_COOKIES' });
    if (response.error) {
      console.error('Failed to load cookies:', response.error);
      return;
    }
    
    state.cookies = response.cookies || [];
    
    if (response.circuitBreakers && response.circuitBreakers.length > 0) {
      showCircuitBreakerAlerts(response.circuitBreakers);
    }
    
    renderCookieList();
    updateStats();
  } catch (error) {
    console.error('Failed to load cookies:', error);
  }
}

async function loadHistory() {
  try {
    const limit = parseInt(document.getElementById('historyLimit').value);
    const response = await browser.runtime.sendMessage({ type: 'GET_HISTORY', limit });
    
    if (response.error) {
      console.error('Failed to load history:', response.error);
      return;
    }
    
    state.history = response.history || [];
    renderHistory();
  } catch (error) {
    console.error('Failed to load history:', error);
  }
}

async function loadMutedDomains() {
  try {
    const response = await browser.runtime.sendMessage({ type: 'GET_SETTINGS' });
    if (response.error) {
      console.error('Failed to load settings:', response.error);
      return;
    }
    
    const result = await browser.storage.local.get('cg_muted_domains');
    state.mutedDomains = result.cg_muted_domains || {};
    
    renderMutedList();
    updateStats();
  } catch (error) {
    console.error('Failed to load muted domains:', error);
  }
}

async function loadSettings() {
  try {
    const response = await browser.runtime.sendMessage({ type: 'GET_SETTINGS' });
    if (response.error) {
      console.error('Failed to load settings:', response.error);
      return;
    }
    
    state.settings = response.settings || {};
    applyTheme(state.settings.theme);
  } catch (error) {
    console.error('Failed to load settings:', error);
  }
}

function renderCookieList() {
  const container = document.getElementById('cookieList');
  
  let filtered = state.cookies.filter(cookie => {
    if (state.filters.search) {
      const searchLower = state.filters.search;
      if (!cookie.name.toLowerCase().includes(searchLower) &&
          !cookie.domain.toLowerCase().includes(searchLower)) {
        return false;
      }
    }
    
    if (state.filters.risk !== 'all' && cookie.riskLevel !== state.filters.risk) {
      return false;
    }
    
    return true;
  });
  
  if (filtered.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <svg class="empty-icon" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10"></circle>
          <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
          <line x1="9" y1="9" x2="9.01" y2="9"></line>
          <line x1="15" y1="9" x2="15.01" y2="9"></line>
        </svg>
        <p class="empty-title">${state.cookies.length === 0 ? 'No cookies detected' : 'No matching cookies'}</p>
        <p class="empty-subtitle">${state.cookies.length === 0 ? 'Browse websites to see cookie activity' : 'Try adjusting your filters'}</p>
      </div>
    `;
    return;
  }
  
  filtered.sort((a, b) => b.timestamp - a.timestamp);
  container.innerHTML = filtered.map(cookie => createCookieItemHTML(cookie)).join('');
  
  container.querySelectorAll('.cookie-item').forEach((item, index) => {
    item.addEventListener('click', () => showCookieDetail(filtered[index]));
  });
}

function createCookieItemHTML(cookie) {
  const riskBadge = `<span class="badge badge-${cookie.riskLevel}">${cookie.riskLevel}</span>`;
  const partitionedBadge = cookie.isPartitioned ? '<span class="badge badge-partitioned">PART</span>' : '';
  const secureBadge = cookie.secure ? '<span class="badge badge-secure">SEC</span>' : '';
  
  return `
    <div class="cookie-item" data-hash="${cookie.identityHash}">
      <div class="cookie-header">
        <div class="cookie-info">
          <div class="cookie-name">${sanitizeInput(cookie.name)}</div>
          <div class="cookie-domain">${sanitizeInput(cookie.domain)}</div>
        </div>
        <div class="cookie-badges">
          ${riskBadge}
          ${partitionedBadge}
          ${secureBadge}
        </div>
      </div>
      <div class="cookie-meta">
        <span>${formatTime(cookie.timestamp)}</span>
        ${cookie.changeCount > 1 ? `<span>${cookie.changeCount} changes</span>` : ''}
      </div>
    </div>
  `;
}

function renderHistory() {
  const container = document.getElementById('historyList');
  
  if (state.history.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <svg class="empty-icon" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
        </svg>
        <p class="empty-title">No history yet</p>
        <p class="empty-subtitle">Cookie events will appear here</p>
      </div>
    `;
    return;
  }

  const RENDER_LIMIT = 100;
  const visibleHistory = state.history.slice(0, RENDER_LIMIT);
  
  container.innerHTML = visibleHistory.map(event => `
    <div class="history-item">
       </div>
  `).join('');

  if (state.history.length > RENDER_LIMIT) {
    const warning = document.createElement('div');
    warning.className = 'history-notice';
    warning.textContent = `Showing recent ${RENDER_LIMIT} of ${state.history.length} events. Export data to see full logs.`;
    container.appendChild(warning);
  }
}

function renderMutedList() {
  const container = document.getElementById('mutedList');
  const mutedEntries = Object.entries(state.mutedDomains);
  
  if (mutedEntries.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <svg class="empty-icon" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
          <line x1="23" y1="9" x2="17" y2="15"></line>
          <line x1="17" y1="9" x2="23" y2="15"></line>
        </svg>
        <p class="empty-title">No muted domains</p>
        <p class="empty-subtitle">Mute domains from cookie context menus</p>
      </div>
    `;
    return;
  }
  
  container.innerHTML = mutedEntries.map(([domain, info]) => `
    <div class="muted-item">
      <div>
        <div class="muted-domain">${sanitizeInput(domain)}</div>
        <div class="muted-date">
          Muted ${formatTime(info.timestamp)}
          ${info.manual ? ' (Manual)' : ''}
        </div>
      </div>
      <button class="btn btn-secondary" onclick="unmuteDomain('${domain}')">Unmute</button>
    </div>
  `).join('');
}

function updateStats() {
  document.getElementById('activeCookies').textContent = state.cookies.length;
  document.getElementById('highRiskCount').textContent = state.cookies.filter(c => c.riskLevel === 'high').length;
  document.getElementById('mutedCount').textContent = Object.keys(state.mutedDomains).length;
}

function switchTab(tabName) {
  state.currentTab = tabName;
  
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.tab === tabName);
  });
  
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });
  
  document.getElementById(`${tabName}Tab`).classList.add('active');
  
  if (tabName === 'history' && state.history.length === 0) {
    loadHistory();
  } else if (tabName === 'muted' && Object.keys(state.mutedDomains).length === 0) {
    loadMutedDomains();
  }
}

function showCookieDetail(cookie) {
  state.selectedCookie = cookie;
  const modal = document.getElementById('detailModal');
  const content = document.getElementById('detailContent');
  
  content.innerHTML = `
    <div class="cookie-detail">
      <div class="detail-section">
        <h3>Identity</h3>
        <div class="detail-row">
          <span>Name</span>
          <strong>${sanitizeInput(cookie.name)}</strong>
        </div>
        <div class="detail-row">
          <span>Domain</span>
          <strong>${sanitizeInput(cookie.domain)}</strong>
        </div>
        <div class="detail-row">
          <span>Path</span>
          <strong>${sanitizeInput(cookie.path)}</strong>
        </div>
      </div>
      
      <div class="detail-section">
        <h3>Classification</h3>
        <div class="detail-row">
          <span>Risk Level</span>
          <strong style="color: var(--risk-${cookie.riskLevel})">${cookie.riskLevel.toUpperCase()}</strong>
        </div>
        <div class="detail-row">
          <span>Third Party</span>
          <strong>${cookie.isThirdParty ? 'Yes' : 'No'}</strong>
        </div>
        <div class="detail-row">
          <span>Partitioned</span>
          <strong>${cookie.isPartitioned ? 'Yes' : 'No'}</strong>
        </div>
      </div>
      
      <div class="detail-section">
        <h3>Security</h3>
        <div class="detail-row">
          <span>Secure</span>
          <strong>${cookie.secure ? 'Yes' : 'No'}</strong>
        </div>
        <div class="detail-row">
          <span>HttpOnly</span>
          <strong>${cookie.httpOnly ? 'Yes' : 'No'}</strong>
        </div>
        <div class="detail-row">
          <span>SameSite</span>
          <strong>${cookie.sameSite || 'None'}</strong>
        </div>
      </div>
      
      <div class="detail-section">
        <h3>Metadata</h3>
        <div class="detail-row">
          <span>Created</span>
          <strong>${new Date(cookie.timestamp).toLocaleString()}</strong>
        </div>
        <div class="detail-row">
          <span>Session</span>
          <strong>${cookie.session ? 'Yes' : 'No'}</strong>
        </div>
        <div class="detail-row">
          <span>Changes</span>
          <strong>${cookie.changeCount}</strong>
        </div>
      </div>
    </div>
  `;
  
  modal.classList.add('active');
}

function openSettings() {
  const panel = document.getElementById('settingsPanel');
  
  document.getElementById('incognitoEnabled').checked = state.settings.incognitoEnabled || false;
  document.getElementById('notificationsEnabled').checked = state.settings.notificationsEnabled !== false;
  document.getElementById('themeSelect').value = state.settings.theme || 'auto';
  document.getElementById('developerMode').checked = state.settings.developerMode || false;
  
  document.getElementById('developerOptions').style.display = state.settings.developerMode ? 'block' : 'none';
  
  loadStorageStats();
  panel.classList.add('active');
}

function closeSettings() {
  const panel = document.getElementById('settingsPanel');
  panel.classList.remove('active');
}

async function autoSaveSettings() {
  const newSettings = {
    incognitoEnabled: document.getElementById('incognitoEnabled').checked,
    notificationsEnabled: document.getElementById('notificationsEnabled').checked,
    theme: document.getElementById('themeSelect').value,
    developerMode: document.getElementById('developerMode').checked,
  };
  
  document.getElementById('developerOptions').style.display = newSettings.developerMode ? 'block' : 'none';

  try {
    await browser.runtime.sendMessage({ type: 'UPDATE_SETTINGS', settings: newSettings });
    
    state.settings = { ...state.settings, ...newSettings };
    applyTheme(newSettings.theme);
  } catch (error) {
    console.error('Failed to auto-save settings:', error);
  }
}

async function loadStorageStats() {
  try {
    document.getElementById('storageUsed').textContent = 'Loading...';
    document.getElementById('eventsRetained').textContent = state.history.length.toString();
  } catch (error) {
    console.error('Failed to load storage stats:', error);
  }
}

async function muteDomainFromDetail() {
  if (!state.selectedCookie) return;
  
  try {
    await browser.runtime.sendMessage({
      type: 'MUTE_DOMAIN',
      domain: state.selectedCookie.etld,
      manual: true,
    });
    
    closeModals();
    await loadMutedDomains();
    await loadActiveCookies();
  } catch (error) {
    console.error('Failed to mute domain:', error);
    alert('Failed to mute domain');
  }
}

window.unmuteDomain = async function(domain) {
  try {
    await browser.runtime.sendMessage({ type: 'UNMUTE_DOMAIN', domain });
    await loadMutedDomains();
    await loadActiveCookies();
  } catch (error) {
    console.error('Failed to unmute domain:', error);
    alert('Failed to unmute domain');
  }
};

async function clearHistory() {
  if (!confirm('Clear all cookie history? This cannot be undone.')) return;
  
  try {
    await browser.runtime.sendMessage({ type: 'CLEAR_HISTORY' });
    state.history = [];
    renderHistory();
  } catch (error) {
    console.error('Failed to clear history:', error);
    alert('Failed to clear history');
  }
}

async function exportData(includeValues) {
  if (includeValues && !confirm('Export will include cookie values. This may contain sensitive data. Continue?')) {
    return;
  }
  
  try {
    const response = await browser.runtime.sendMessage({ type: 'EXPORT_DATA', includeValues });
    
    if (response.error) {
      alert(response.error);
      return;
    }
    
    const blob = new Blob([JSON.stringify(response.data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `cookieguard-export-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Failed to export data:', error);
    alert('Failed to export data');
  }
}

async function refreshActiveData() {
  await loadActiveCookies();
}

function applyTheme(theme) {
  if (theme === 'dark') {
    document.documentElement.setAttribute('data-theme', 'dark');
  } else if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
  } else {
    document.documentElement.removeAttribute('data-theme');
  }
}

function closeModals() {
  document.querySelectorAll('.modal').forEach(modal => {
    modal.classList.remove('active');
  });
  state.selectedCookie = null;
}

function showCircuitBreakerAlerts(domains) {
  const container = document.getElementById('circuitBreakerAlerts');
  container.innerHTML = domains.map(domain => `
    <div class="alert">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2L1 21h22L12 2zm0 3.5L19.5 19h-15L12 5.5zM11 10v4h2v-4h-2zm0 6v2h2v-2h-2z"/>
      </svg>
      <span>High activity from <strong>${sanitizeInput(domain)}</strong> has been muted temporarily</span>
    </div>
  `).join('');
}

function showFirstLaunchWizard() {
  const modal = document.getElementById('firstLaunchModal');
  modal.style.display = 'flex';
}

function completeWizard() {
  const modal = document.getElementById('firstLaunchModal');
  modal.style.display = 'none';
  window.location.href = 'popup.html';
}
</file>

<file path="src/popup/style.css">
:root {
  --bg-primary: #ffffff;
  --bg-secondary: #f8fafc;
  --bg-tertiary: #f1f5f9;
  --bg-hover: #e2e8f0;
  --text-primary: #0f172a;
  --text-secondary: #475569;
  --text-tertiary: #94a3b8;
  --border: #e2e8f0;
  --border-hover: #cbd5e1;
  --accent-primary: #3b82f6;
  --accent-hover: #2563eb;
  --accent-light: #dbeafe;
  --risk-high: #ef4444;
  --risk-medium: #f59e0b;
  --risk-low: #10b981;
  --success: #10b981;
  --warning: #f59e0b;
  --danger: #ef4444;
  --info: #3b82f6;
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --radius-sm: 6px;
  --radius-md: 8px;
  --radius-lg: 12px;
  --transition: 150ms cubic-bezier(0.4, 0, 0.2, 1);
}

[data-theme="dark"] {
  --bg-primary: #0f172a;
  --bg-secondary: #1e293b;
  --bg-tertiary: #334155;
  --bg-hover: #475569;
  --text-primary: #f1f5f9;
  --text-secondary: #cbd5e1;
  --text-tertiary: #94a3b8;
  --border: #334155;
  --border-hover: #475569;
  --accent-primary: #60a5fa;
  --accent-hover: #3b82f6;
  --accent-light: #1e3a8a;
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
}

@media (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) {
    --bg-primary: #0f172a;
    --bg-secondary: #1e293b;
    --bg-tertiary: #334155;
    --bg-hover: #475569;
    --text-primary: #f1f5f9;
    --text-secondary: #cbd5e1;
    --text-tertiary: #94a3b8;
    --border: #334155;
    --border-hover: #475569;
    --accent-primary: #60a5fa;
    --accent-hover: #3b82f6;
    --accent-light: #1e3a8a;
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
  }
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  width: 600px;
  min-height: 400px;
  max-height: 600px;
  font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', Roboto, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  color: var(--text-primary);
  background: var(--bg-primary);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.header {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  padding: 16px;
}

.header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.logo {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
  letter-spacing: -0.02em;
}

.logo-icon {
  color: var(--accent-primary);
}

.header-actions {
  display: flex;
  gap: 8px;
}

.icon-btn {
  background: transparent;
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  padding: 8px;
  cursor: pointer;
  color: var(--text-secondary);
  transition: all var(--transition);
  display: flex;
  align-items: center;
  justify-content: center;
}

.icon-btn:hover {
  background: var(--bg-hover);
  border-color: var(--border-hover);
  color: var(--text-primary);
}

.stats-bar {
  display: flex;
  gap: 24px;
  padding-top: 16px;
  border-top: 1px solid var(--border);
  justify-content: center;
}

.stat {
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: center;
  min-width: 60px;
}

.stat-label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.stat-value {
  font-size: 24px;
  font-weight: 700;
  color: var(--text-primary);
  line-height: 1;
}

.stat-risk {
  color: var(--risk-high);
}

.tabs {
  display: flex;
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
}

.tab {
  flex: 1;
  background: transparent;
  border: none;
  padding: 14px 16px;
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all var(--transition);
  border-bottom: 2px solid transparent;
}

.tab:hover {
  color: var(--text-primary);
  background: var(--bg-secondary);
}

.tab.active {
  color: var(--accent-primary);
  border-bottom-color: var(--accent-primary);
}

.content {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.filter-bar {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}

.search-input {
  flex: 1;
  padding: 10px 14px;
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  font-size: 14px;
  color: var(--text-primary);
  background: var(--bg-primary);
  transition: all var(--transition);
}

.search-input:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 3px var(--accent-light);
}

.filter-select {
  padding: 10px 14px;
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  font-size: 14px;
  color: var(--text-primary);
  background: var(--bg-primary);
  cursor: pointer;
  transition: all var(--transition);
}

.filter-select:focus {
  outline: none;
  border-color: var(--accent-primary);
}

.cookie-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.cookie-item {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  padding: 14px;
  cursor: pointer;
  transition: all var(--transition);
}

.cookie-item:hover {
  border-color: var(--border-hover);
  box-shadow: var(--shadow-sm);
  transform: translateY(-1px);
}

.cookie-header {
  display: flex;
  justify-content: space-between;
  align-items: start;
  margin-bottom: 10px;
}

.cookie-info {
  flex: 1;
  min-width: 0;
}

.cookie-name {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 14px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.cookie-domain {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 2px;
}

.cookie-badges {
  display: flex;
  gap: 6px;
  flex-shrink: 0;
}

.badge {
  padding: 3px 8px;
  border-radius: var(--radius-sm);
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.badge-high {
  background: rgba(239, 68, 68, 0.1);
  color: var(--risk-high);
}

.badge-medium {
  background: rgba(245, 158, 11, 0.1);
  color: var(--risk-medium);
}

.badge-low {
  background: rgba(16, 185, 129, 0.1);
  color: var(--risk-low);
}

.badge-partitioned {
  background: rgba(59, 130, 246, 0.1);
  color: var(--info);
}

.badge-secure {
  background: rgba(16, 185, 129, 0.1);
  color: var(--success);
}

.cookie-meta {
  display: flex;
  gap: 16px;
  font-size: 12px;
  color: var(--text-tertiary);
}

.history-notice {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 14px;
  background: var(--accent-light);
  border-radius: var(--radius-md);
  font-size: 12px;
  color: var(--accent-primary);
  margin-bottom: 16px;
}

.history-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.history-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.history-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  font-size: 13px;
}

.history-action {
  font-weight: 500;
  color: var(--text-primary);
}

.history-action.added {
  color: var(--success);
}

.history-action.removed {
  color: var(--danger);
}

.history-time {
  color: var(--text-tertiary);
  font-size: 12px;
}

.muted-notice {
  padding: 14px;
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
  font-size: 13px;
  color: var(--text-secondary);
  margin-bottom: 16px;
}

.muted-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.muted-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 14px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
}

.muted-domain {
  font-weight: 500;
  color: var(--text-primary);
}

.muted-date {
  font-size: 12px;
  color: var(--text-tertiary);
  margin-top: 2px;
}

.alert-container {
  margin-bottom: 16px;
}

.alert {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px 14px;
  background: rgba(245, 158, 11, 0.1);
  border: 1px solid var(--warning);
  border-radius: var(--radius-md);
  color: var(--warning);
  font-size: 13px;
  font-weight: 500;
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 48px 32px;
  text-align: center;
}

.empty-icon {
  margin-bottom: 16px;
  opacity: 0.3;
  color: var(--text-tertiary);
}

.empty-title {
  font-size: 16px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 6px;
}

.empty-subtitle {
  font-size: 14px;
  color: var(--text-secondary);
}

.btn {
  padding: 10px 16px;
  border: none;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition);
}

.btn-primary {
  background: var(--accent-primary);
  color: white;
}

.btn-primary:hover {
  background: var(--accent-hover);
  transform: translateY(-1px);
  box-shadow: var(--shadow-sm);
}

.btn-secondary {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--border);
}

.btn-secondary:hover {
  background: var(--bg-hover);
  border-color: var(--border-hover);
}

.btn-danger {
  background: var(--danger);
  color: white;
}

.btn-danger:hover {
  background: #dc2626;
}

.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(8px);
  z-index: 1000;
  align-items: center;
  justify-content: center;
}

.modal.active {
  display: flex;
}

.modal-content {
  background: var(--bg-primary);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-lg);
  max-width: 500px;
  max-height: 80vh;
  width: 90%;
  display: flex;
  flex-direction: column;
  border: 1px solid var(--border);
}

.modal-content.wizard {
  max-width: 540px;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
}

.modal-header h2 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.modal-close {
  background: transparent;
  border: none;
  font-size: 28px;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--radius-sm);
  transition: all var(--transition);
}

.modal-close:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

.modal-body {
  padding: 32px;
  overflow-y: auto;
  flex: 1;
}

.modal-footer {
  padding: 20px 24px;
  border-top: 1px solid var(--border);
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

.setting-group {
  margin-bottom: 32px;
}

.setting-group:last-child {
  margin-bottom: 0;
}

.setting-group h3 {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-tertiary);
  margin-bottom: 16px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.setting-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
  margin-bottom: 10px;
  cursor: pointer;
  transition: all var(--transition);
  border: 1px solid transparent;
}

.setting-item:hover {
  background: var(--bg-hover);
  border-color: var(--border);
}

.setting-info {
  flex: 1;
  padding-right: 16px;
}

.setting-label {
  display: block;
  font-weight: 500;
  font-size: 14px;
  color: var(--text-primary);
  margin-bottom: 4px;
}

.setting-description {
  display: block;
  font-size: 13px;
  color: var(--text-secondary);
  line-height: 1.4;
}

.toggle {
  appearance: none;
  width: 44px;
  height: 24px;
  background: var(--border);
  border-radius: 12px;
  position: relative;
  cursor: pointer;
  transition: background var(--transition);
  flex-shrink: 0;
}

.toggle:checked {
  background: var(--accent-primary);
}

.toggle::before {
  content: '';
  position: absolute;
  width: 18px;
  height: 18px;
  background: white;
  border-radius: 50%;
  top: 3px;
  left: 3px;
  transition: transform var(--transition);
  box-shadow: var(--shadow-sm);
}

.toggle:checked::before {
  transform: translateX(20px);
}

.setting-select {
  padding: 10px 14px;
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  font-size: 14px;
  color: var(--text-primary);
  background: var(--bg-primary);
}

.developer-options {
  padding: 16px;
  background: var(--bg-tertiary);
  border-radius: var(--radius-md);
  margin-top: 10px;
  border: 1px solid var(--border);
}

.developer-options .btn {
  width: 100%;
  margin-bottom: 10px;
}

.developer-options .btn:last-of-type {
  margin-bottom: 12px;
}

.warning-text {
  font-size: 12px;
  color: var(--warning);
  line-height: 1.4;
}

.storage-stats {
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
  padding: 4px;
  border: 1px solid var(--border);
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 12px 14px;
  font-size: 13px;
  border-bottom: 1px solid var(--border);
}

.stat-row:last-child {
  border-bottom: none;
}

.stat-row span:first-child {
  color: var(--text-secondary);
}

.stat-row span:last-child {
  font-weight: 500;
  color: var(--text-primary);
}

.about-info {
  font-size: 13px;
  line-height: 1.7;
}

.about-info p {
  margin-bottom: 12px;
}

.about-info p:last-child {
  margin-bottom: 0;
}

.disclaimer {
  color: var(--text-secondary);
  font-style: italic;
  font-size: 12px;
}

.library-version {
  color: var(--text-tertiary);
  font-size: 12px;
}

.wizard-container {
  max-width: 460px;
  margin: 0 auto;
}

.wizard-header {
  text-align: center;
  margin-bottom: 40px;
}

.wizard-icon {
  width: 72px;
  height: 72px;
  margin: 0 auto 24px;
  background: linear-gradient(135deg, #3b82f6 0%, #6366f1 100%);
  border-radius: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3);
}

.wizard-icon svg {
  color: white;
}

.wizard-title {
  font-size: 26px;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 12px;
  letter-spacing: -0.02em;
  line-height: 1.2;
}

.wizard-subtitle {
  font-size: 15px;
  color: var(--text-secondary);
  line-height: 1.6;
}

.wizard-features {
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-bottom: 32px;
}

.wizard-feature {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  padding: 20px;
  display: flex;
  align-items: flex-start;
  gap: 16px;
  transition: all 0.3s ease;
}

.wizard-feature:hover {
  border-color: var(--border-hover);
  box-shadow: var(--shadow-sm);
  transform: translateY(-2px);
}

.wizard-feature-icon {
  width: 44px;
  height: 44px;
  background: var(--bg-tertiary);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  border: 1px solid var(--border);
}

.wizard-feature-icon svg {
  color: var(--accent-primary);
}

.wizard-feature-content {
  flex: 1;
  padding-top: 2px;
}

.wizard-feature-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 6px;
  letter-spacing: -0.01em;
}

.wizard-feature-text {
  font-size: 13px;
  color: var(--text-secondary);
  line-height: 1.5;
  margin: 0;
}

.wizard-philosophy {
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(99, 102, 241, 0.08) 100%);
  border: 1px solid rgba(59, 130, 246, 0.2);
  border-radius: var(--radius-lg);
  padding: 20px;
  margin-bottom: 32px;
  position: relative;
}

.wizard-philosophy::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 4px;
  background: linear-gradient(180deg, #3b82f6, #6366f1);
  border-radius: 4px 0 0 4px;
}

.wizard-philosophy-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--accent-primary);
  margin-bottom: 8px;
  letter-spacing: -0.01em;
}

.wizard-philosophy-text {
  font-size: 13px;
  color: var(--text-secondary);
  line-height: 1.6;
  margin: 0;
}

.wizard-cta {
  width: 100%;
  background: linear-gradient(135deg, #3b82f6 0%, #6366f1 100%);
  color: white;
  border: none;
  border-radius: var(--radius-lg);
  padding: 16px 32px;
  font-size: 15px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 8px 20px rgba(59, 130, 246, 0.25);
  letter-spacing: -0.01em;
}

.wizard-cta:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 28px rgba(59, 130, 246, 0.35);
}

.wizard-cta:active {
  transform: translateY(0);
}

.cookie-detail {
  font-size: 13px;
}

.detail-section {
  margin-bottom: 24px;
}

.detail-section:last-child {
  margin-bottom: 0;
}

.detail-section h3 {
  font-size: 11px;
  font-weight: 700;
  margin-bottom: 12px;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.detail-row {
  display: flex;
  justify-content: space-between;
  padding: 12px 0;
  border-bottom: 1px solid var(--border);
}

.detail-row:last-child {
  border-bottom: none;
}

.detail-row span:first-child {
  color: var(--text-secondary);
}

.detail-row strong {
  font-weight: 500;
  color: var(--text-primary);
}

::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--border-hover);
}

.settings-panel {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--bg-primary);
  z-index: 2000;
  transform: translateX(100%);
  transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
  display: flex;
  flex-direction: column;
}

.settings-panel.active {
  transform: translateX(0);
}

.settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.settings-header h2 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
}

.nav-back-btn {
  background: none;
  border: none;
  color: var(--text-primary);
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.2s;
}

.nav-back-btn:hover {
  background: var(--bg-hover);
}

.settings-body {
  flex: 1;
  overflow-y: auto;
  padding: 0 16px 32px 16px;
}

.setting-group {
  margin-top: 24px;
}

.setting-group h3 {
  margin-left: 4px;
  margin-bottom: 8px;
  color: var(--accent-primary);
}

.setting-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 4px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
}

.setting-row:last-child {
  border-bottom: none;
}

.settings-footer-info {
  margin-top: 40px;
  text-align: center;
  color: var(--text-tertiary);
  font-size: 12px;
}

.settings-footer-info .subtle {
  opacity: 0.7;
}

.storage-stats-clean {
  display: flex;
  gap: 16px;
  padding: 0 4px;
}

.stat-clean {
  display: flex;
  flex-direction: column;
}

.stat-key {
  font-size: 11px;
  color: var(--text-tertiary);
  text-transform: uppercase;
}

.stat-val {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-primary);
}
</file>

<file path="src/manifest.json">
{
  "manifest_version": 3,
  "name": "CookieGuard",
  "version": "1.0.0",
  "description": "Zero-Trust cookie visibility. Local-only architecture. Optimized for Firefox.",
  "author": "TheJaydenProject",
  "icons": {
    "16": "assets/icons/icon16.png",
    "48": "assets/icons/icon48.png",
    "128": "assets/icons/icon128.png"
  },
  "background": {
    "scripts": ["background/service-worker.js"],
    "type": "module"
  },
  "action": {
    "default_popup": "popup/popup.html",
    "default_title": "CookieGuard",
    "browser_style": true
  },
  "permissions": [
    "cookies",
    "storage",
    "tabs",
    "notifications",
    "alarms"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "browser_specific_settings": {
    "gecko": {
      "id": "cookieguard@thejaydenproject",
      "strict_min_version": "115.0"
    }
  },
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'none'"
  }
}
</file>

</files>
